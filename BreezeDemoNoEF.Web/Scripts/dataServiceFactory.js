var dataServiceFactory = (function () {
    'use strict';

    return function emFactory(config) {
        // Extract Breeze metadata definition types
        var DT = breeze.DataType;
        var ID = breeze.DataType.Int32;
        var KEYTYPE = breeze.AutoGeneratedKeyType.Identity;
        var Validator = breeze.Validator;

        // Convert server-side PascalCase to client-side camelCase property names
        //breeze.NamingConvention.camelCase.setAsDefault();

        // Do not validate when we attach a newly created entity to an EntityManager.
        // We could also set this per entityManager
        new breeze.ValidationOptions({ validateOnAttach: true }).setAsDefault();

        var newManager = function() {
            var dataService = new breeze.DataService({
                serviceName: config.remoteServiceName,
                hasServerMetadata: false // don't ask the server for metadata
            });
            var mgr = new breeze.EntityManager({ dataService: dataService });
            configureDataService(mgr.metadataStore);
            return mgr;
        }

        var configureDataService = function (metadataStore) {
            addOrderType();
            addOrderDetailType();

            // Type definitions

            function addOrderType() {
                metadataStore.addEntityType({
                    shortName: "Order",
                    namespace: "BreezeDemoNoEF.Web.Models",
                    autoGeneratedKeyType: KEYTYPE,
                    defaultResourceName: "Orders",
                    dataProperties: {
                        Id: { dataType: ID, isNullable: false, isPartOfKey: true },
                        Customer: {
                            maxLength: 30, isNullable: false,
                            // Add client-side validation to 'Customer Name'
                            validators: [Validator.required(), Validator.maxLength({ maxLength: 30 })]
                        },
                        OrderDate: { dataType: DT.DateTime, isNullable: false }
                    },
                    navigationProperties: {
                        OrderDetails: { entityTypeName: "OrderDetail", isScalar: false, associationName: "Order_OrderDetails" }
                    }
                });

                metadataStore.registerEntityTypeCtor("Order", null, orderInitializer);

                function orderInitializer(order) {
                    // add unpersisted, untracked properties for UI purposes
                    order.errorMessage = ko.observable();
                }
            }

            function addOrderDetailType() {
                metadataStore.addEntityType({
                    shortName: "OrderDetail",
                    namespace: "BreezeDemoNoEF.Web.Models",
                    //autoGeneratedKeyType: KEYTYPE,
                    defaultResourceName: "OrderDetails",
                    dataProperties: {
                        Id: { dataType: ID, isNullable: false, isPartOfKey: true },
                        Quantity: { dataType: DT.Int32, isNullable: false },
                        ProductId: { dataType: DT.Int32, isNullable: false },
                        OrderId: { dataType: DT.Int32, isNullable: false }
                    },
                    navigationProperties: {
                        Order: { entityTypeName: "Order", isScalar: true, foreignKeyNames: ["OrderId"], associationName: "Order_OrderDetails" }
                    }
                });
            }
        };
        
        function saveEntity(masterEntity, manager) {

            return manager.saveChanges().catch(saveFailed);

            function saveFailed(error) {
                setErrorMessage(error);
                // Let them see it "wrong" briefly before reverting"
                setTimeout(function () { manager.rejectChanges(); }, 1000);
                throw error; // so caller can see failure
            }

            function setErrorMessage(error) {
                var statename = masterEntity.entityAspect.entityState.name.toLowerCase();
                var typeName = masterEntity.entityType.shortName;
                var msg = "Error saving " + statename + " " + typeName + ": ";

                var reason = error.message;

                if (error.entityErrors) {
                    reason = getValidationErrorMessage(error);
                } else if (isConcurrencyError(error)) {
                    reason =
                        "can't find " + typeName + "; another user may have deleted it.";
                }
                masterEntity.errorMessage(msg + reason);
            }

            function getValidationErrorMessage(error) {
                try { // return the first error message
                    var firstError = error.entityErrors[0];
                    return firstError.errorMessage;
                } catch (e) { // ignore problem extracting error message 
                    return "validation error";
                }
            }

            function isConcurrencyError(error) {
                var detail = error.detail;
                return detail && detail.ExceptionMessage &&
                    detail.ExceptionMessage.match(/can't find/i);
            }
        }

        var provider = {
            newManager: newManager,
            saveEntity: saveEntity
        };

        return provider;
    }
})();